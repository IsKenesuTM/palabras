<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Part√≠culas - Liz (Estable)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .center{ position:fixed; inset:0; display:grid; place-items:center; pointer-events:none; }
    button{
      pointer-events:auto;
      background:#111; color:#fff; border:1px solid #333;
      padding:14px 22px; border-radius:999px; font-size:16px;
      cursor:pointer; letter-spacing:.5px;
      box-shadow:0 10px 30px rgba(0,0,0,.55);
      transition:transform .12s ease, background .12s ease;
    }
    button:hover{ background:#1a1a1a; transform:translateY(-1px); }
    button:active{ transform:translateY(0) scale(.99); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="center" id="ui"><button id="btn">Haz click üíñ</button></div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // ========= CONFIG (AJUSTA AQU√ç) =========
 const WORDS = [
  "TE QUIERO",
  "HERMOSA",
  "LIZ MI AMOR",
  "MI VIDA",
  "MI CIELO",
  "MI CORAZ√ìN",
  "MI ALMA",
  "MI TESORO",
  "MI TODO",
  "TE ADORO",
  "TE AMO",
  "TE ELIJO",
  "SIEMPRE CONTIGO",
  "JUNTOS SIEMPRE",
  "ERES MI LUZ",
  "ERES MI PAZ",
  "ERES MI HOGAR",
  "ERES MI DESTINO",
  "ERES MI SUE√ëO",
  "ERES MI MAGIA",
  "ME ENCANTAS",
  "ME FASCINAS",
  "ME INSPIRAS",
  "ME HACES FELIZ",
  "ME HACES SONRE√çR",
  "ME HACES BIEN",
  "ME GUSTAS MUCHO",
  "TE PIENSO",
  "TE EXTRA√ëO",
  "TE NECESITO",
  "TE QUIERO M√ÅS",
  "CADA D√çA M√ÅS",
  "CADA MOMENTO",
  "CADA LATIDO",
  "CADA SUSPIRO",
  "HASTA EL FIN",
  "PARA SIEMPRE",
  "POR SIEMPRE",
  "INFINITO",
  "ETERNIDAD",
  "MI BONITA",
  "MI HERMOSA",
  "MI PRECIOSA",
  "MI REINA",
  "MI PRINCESA",
  "MI ESTRELLA",
  "MI LUNITA",
  "MI SOL",
  "MI UNIVERSO",
  "MI BENDICI√ìN",
  "MI SUERTE",
  "MI ALEGR√çA",
  "MI SONRISA",
  "MI CALMA",
  "MI REFUGIO",
  "MI COMPLICIDAD",
  "MI PASI√ìN",
  "MI ROMANCE",
  "MI POES√çA",
  "MI CANCI√ìN",
  "MI AVENTURA",
  "MI FUTURO",
  "MI FAMILIA",
  "MI COMPROMISO",
  "MI PROMESA",
  "TE CUIDO",
  "TE PROTEJO",
  "TE VALORO",
  "TE RESPETO",
  "TE ADMIR0",
  "CONF√çO EN TI",
  "GRACIAS POR TI",
  "GRACIAS AMOR",
  "CONTIGO TODO",
  "CONTIGO SIEMPRE",
  "CONTIGO ES MEJOR",
  "NOSOTROS",
  "NUESTRO AMOR",
  "AMOR BONITO",
  "AMOR SINCERO",
  "AMOR ETERNO",
  "BESITOS",
  "ABRAZITOS",
  "UN BESO",
  "MIL BESOS",
  "UN ABRAZO",
  "MIL ABRAZOS",
  "T√ö Y YO",
  "SOLO T√ö",
  "NADIE COMO T√ö",
  "ERES √öNICA",
  "ERES ESPECIAL",
  "ERES PERFECTA",
  "ERES INCRE√çBLE",
  "ERES TODO",
  "MI VIDA CONTIGO",
  "TE AMO LIZ",
  "LIZ TE QUIERO"
];


  const BG = "#000";
  const COLOR = "#ff2b2b";
  const GLOW  = "rgba(255, 43, 43, 0.7)";

  // Densidad base (m√°s bajo = m√°s part√≠culas). Se ajusta autom√°ticamente si excede MAX_PARTICLES.
  let BASE_STEP = 3;

  // L√≠mite para que NO se sature (PC: 16000-22000 / Cel: 9000-14000)
  const MAX_PARTICLES = 14000;

  // Velocidad de lectura
  const MORPH_MS = 1800; // transici√≥n palabra->palabra (m√°s alto = m√°s suave)
  const HOLD_MS  = 2400; // cu√°nto dura visible (m√°s alto = se lee mejor)

  // Efectos visuales (anti-saturaci√≥n)
  const USE_TRAIL = false;    // <- pon true si quieres estela
  const TRAIL_ALPHA = 0.20;   // si USE_TRAIL=true, 0.15-0.30 (m√°s alto = se limpia m√°s)
  const SHADOW_BLUR = 12;     // brillo
  // =======================================

  const off = document.createElement("canvas");
  const offCtx = off.getContext("2d", { willReadFrequently:true });

  let W=0, H=0, DPR=1;
  let running=false;

  let particles=[];
  let wordIndex=0;

  let phase="idle"; // morph | hold
  let phaseStart=0;

  // cache de puntos por palabra para no recalcular de m√°s (se invalida al resize)
  let pointsCache = new Map();

  class P {
    constructor(x,y){
      this.x=x; this.y=y;
      this.sx=x; this.sy=y;
      this.tx=x; this.ty=y;
      this.size = 1.1 + Math.random()*1.1;
      this.seed = Math.random()*9999;
      this.delay = Math.random()*0.18; // peque√±a ola (no exagerada)
      this.active=true;
    }
    setTarget(tx,ty){
      this.sx = this.x; this.sy = this.y;
      this.tx = tx; this.ty = ty;
    }
  }

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    off.width = W; off.height = H;

    // Ajuste r√°pido para m√≥vil
    const minSide = Math.min(window.innerWidth, window.innerHeight);
    BASE_STEP = minSide < 420 ? 4 : 3;

    pointsCache.clear();

    // Limpia pantalla
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,W,H);
  }

  function fitFont(word){
    const base = Math.min(window.innerWidth, window.innerHeight);
    let fontPx = Math.max(56, Math.floor(base * 0.17));
    offCtx.textAlign="center";
    offCtx.textBaseline="middle";

    while (fontPx > 28) {
      offCtx.font = `900 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      if (offCtx.measureText(word).width <= W * 0.88) break;
      fontPx -= 4;
    }
    return fontPx;
  }

  function samplePoints(word){
    // cache por palabra (dependiente del tama√±o actual)
    if (pointsCache.has(word)) return pointsCache.get(word);

    const fontPx = fitFont(word);

    // intentamos con step base, y si excede MAX_PARTICLES, subimos step autom√°ticamente
    let step = BASE_STEP;
    let pts = [];

    while (true) {
      offCtx.clearRect(0,0,W,H); // transparente
      offCtx.font = `900 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      offCtx.fillStyle = "rgba(255,255,255,1)";
      offCtx.fillText(word, W/2, H/2);

      const data = offCtx.getImageData(0,0,W,H).data;
      pts.length = 0;

      for (let y=0; y<H; y+=step) {
        for (let x=0; x<W; x+=step) {
          const i = (y*W + x) * 4;
          if (data[i+3] > 70) pts.push([x,y]);
        }
      }

      if (pts.length <= MAX_PARTICLES || step >= 10) break;
      step += 1; // sube step para reducir puntos (evita saturaci√≥n)
    }

    // mezcla para que el ‚Äúmorph‚Äù se vea org√°nico
    for (let i=pts.length-1; i>0; i--){
      const j = (Math.random()*(i+1))|0;
      [pts[i], pts[j]] = [pts[j], pts[i]];
    }

    pointsCache.set(word, pts);
    return pts;
  }

  function ensureParticles(n){
    while (particles.length < n) particles.push(new P(Math.random()*W, Math.random()*H));
    for (let i=0;i<particles.length;i++) particles[i].active = i < n;
  }

  function morphTo(word){
    const pts = samplePoints(word);
    const n = Math.min(pts.length, MAX_PARTICLES);

    ensureParticles(n);

    // asigna target 1 a 1 (sin duplicar => no se ‚Äúembarra‚Äù)
    for (let i=0;i<n;i++){
      const p = particles[i];
      const [tx,ty] = pts[i];
      p.setTarget(tx,ty);
    }

    phase="morph";
    phaseStart=performance.now();
  }

  function nextWord(){
    const word = WORDS[wordIndex % WORDS.length];
    wordIndex++;
    morphTo(word);
  }

  // easing suave
  function easeInOut(t){
    return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
  }

  function renderBackground(){
    if (!USE_TRAIL) {
      ctx.fillStyle = BG;
      ctx.fillRect(0,0,W,H);
    } else {
      ctx.fillStyle = `rgba(0,0,0,${TRAIL_ALPHA})`;
      ctx.fillRect(0,0,W,H);
    }
  }

  function animate(t){
    if (!running) return;

    renderBackground();

    ctx.fillStyle = COLOR;
    ctx.shadowBlur = SHADOW_BLUR;
    ctx.shadowColor = GLOW;

    const dt = t - phaseStart;

    if (phase === "morph") {
      let progress = Math.min(1, dt / MORPH_MS);

      for (const p of particles) {
        if (!p.active) continue;

        // peque√±a ola, pero controlada (no tapa el texto)
        const local = Math.min(1, Math.max(0, (progress - p.delay) / (1 - p.delay)));
        const k = easeInOut(local);

        // interpolaci√≥n directa (evita ‚Äúexplosiones‚Äù raras)
        const wig = 0.8 * DPR;
        const ox = Math.sin(t*0.002 + p.seed) * wig;
        const oy = Math.cos(t*0.0022 + p.seed) * wig;

        p.x = p.sx + (p.tx - p.sx) * k + ox;
        p.y = p.sy + (p.ty - p.sy) * k + oy;

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * DPR, 0, Math.PI*2);
        ctx.fill();
      }

      if (progress >= 1) {
        phase="hold";
        phaseStart=t;
      }
    } else if (phase === "hold") {
      // quieto con vibraci√≥n leve (se lee bien)
      for (const p of particles) {
        if (!p.active) continue;
        const wig = 1.2 * DPR;
        const ox = Math.sin(t*0.0018 + p.seed) * wig;
        const oy = Math.cos(t*0.0020 + p.seed*1.07) * wig;

        p.x = p.tx + ox;
        p.y = p.ty + oy;

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * DPR, 0, Math.PI*2);
        ctx.fill();
      }

      if (dt >= HOLD_MS) nextWord();
    }

    ctx.shadowBlur = 0;
    requestAnimationFrame(animate);
  }

  document.getElementById("btn").addEventListener("click", ()=>{
    if (running) return;
    running=true;
    document.getElementById("ui").style.display="none";

    // arranque centrado (bonito y controlado)
    resize();
    ensureParticles(Math.min(9000, MAX_PARTICLES));
    for (const p of particles) {
      if (!p.active) continue;
      p.x = W/2 + (Math.random()-0.5) * 40 * DPR;
      p.y = H/2 + (Math.random()-0.5) * 40 * DPR;
      p.sx = p.x; p.sy = p.y;
    }

    nextWord();
    requestAnimationFrame(animate);
  });

  window.addEventListener("resize", resize);
  resize();
})();
</script>
</body>
</html>
